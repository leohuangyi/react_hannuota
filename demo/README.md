# 深入React学习之疯狂的汉诺塔
## [疯狂的汉诺塔](http://www.xwlj.net/demo/react/react_hannuota/demo)
React是一款设计巧妙的界面库，这周继续对它进行了深入的学习，并写了一款小游戏，有时间各位可以试试，挑战一下自己的朋友吧。

接下来，我们先学习两个使用React的优化点，然后再解析这个小游戏的实现。

## 组件的生命周期优化

React主要通过生命周期函数来控制一个组件，它将组件分为三个周期：

1. 实例化期： 在这里，我们可以分配组件的初始属性(props)和状态(state)，渲染组件的html，
2. 存在期：组件的生命价值将在这里体现，我们可以在这里响应组件的属性和状态的改变，从而调整组件的html结构或进行一些其他操作诸如数据交流、传递。
3. 销毁期：当组件完成使命后，我们便可以在这里解绑事件、释放资源

在每个周期，React将依次调用以下函数：
![周期函数](https://img.alicdn.com/tps/TB1XcY5IVXXXXa8XXXXXXXXXXXX-952-622.png)

在组件存在期，每次属性/状态的改变，React都会调用render函数来计算组件的html结构，如果有变更，React便将变更同步到浏览器DOM中，尽管React很快，但是并非所有的属性/状态改变都会影响到组件的DOM，尤其是render函数比较复杂的组件，频繁的调用render将可能导致组件产生延迟。优秀的开发者不会放弃任何一丝提升系统性能的机会，我们可以在`shouldComponentUpdate`这个函数中捕捉属性/状态的改变，通过返回true便可以阻止React再调用render函数。

## 复用代码

不编写重复的代码块，尽可能的复用代码。在React中，我们可以利用`mixin`来复用我们的代码。举个例子：

```
	/* 系统中有一个评论组件，一个留言组件，它们都需要和谐用户的输入，我们需要一个方法来过滤输入，显然我们不能在每个组件中都实现一次这个方法，mixin的功效便体现出来啦 */

	/* 实现了一个和谐用户输入的函数 */
	var FilterInput = function(input){
		/* 这里进行一些过滤工作 */
		return outPut；
	}

	/* 评论组件 */
	var CommentClass = new React.createClass({
		mixins: [ FilterInput ]
		render : function(){
			/* 这里直接通过调用this.FilterInput来和谐用户的输入 */
			var outPut = this.FilterInput(input);
			......
		}
		...
	});

	/* 留言组件 */
	var MessageClass = new React.createClass({
		mixins: [ FilterInput ],
		render : function(){
			...
		}
		...
	});

```

简单的说`mixin`就是混入组件类中的对象，它还有一些高级用法，比如我们可以混入React原生定义的一些生命周期方法，React并不会简单的覆盖，对于以component开头的生命周期方法，如componentDidMount，componentDidUpdate等，React会按照`mixin`数组中定义的顺序调用，并最终调用组件自带的方法。灵活的使用`mixin`可以让我们的组件专注于自生的业务逻辑，便于组件代码逻辑的梳理。


## 解析汉诺塔游戏的实现

汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘——来自百科


### 模型建立

#### 规则模型：

我们可以将圆盘编号，盘子越大，编号越大，将每根柱子上的的圆盘集合看成一个`栈`，栈顶只能压入编号比上一个盘子编号小的盘子(如果该柱没有盘子则可以直接压入)。在JS的实现中，我们可以用`Array`来实现这个`栈`，每当有盘子试图移向某柱子时，比较该柱栈顶的盘子编号与将要移入的盘子编号，如果符合移入条件则调用`pop()`从盘子来自的柱子的栈弹出该盘子编号,再调用`push()`将该盘子的编号压入将要移向的柱子的栈。

#### 计分模型：

为了提升游戏的竞争性，我们需要从游戏的难度和耗费的时间来计算玩家的分数。即将分数拆分成基础分和时间分

- 基础分： n个盘子要完成移动的最小次数为：h(n) = 2 ^ n - 1，次数越多表明游戏难度越大，为了拉开各个难度的分差，我们将h(n) * 10得到了游戏的基础分
- 时间分：耗费的时间越短，分数越高，要实现这个计分模型，我们需要一个单调递减的函数，为了减少计算的复杂度，我们可以使用一次函数描述这个模型。确定一个函数需要两个点，
	- 点1：假定每次移动需要耗费约1.5秒，则最佳完成游戏的时间为1.5 * h(n),我们将这个点完成游戏的分数定为100 * 1.5 * h(n) (很多时候，不同玩家完成的时间差距可能较短，为了拉大分差，于是将系数从10提到了100)
	- 点2：假定4倍的最佳时间过去了，玩家还没完成，则时间分数为0

最后，将基础分加上时间分便形成了游戏的计分模型。

### React干了什么

在这个游戏中，我们可以使用两个React类来实现这个游戏，下面我简单描述每个类的功能和主要函数，详细代码请见：[React_HanNuoTa](https://code.csdn.net/leohuangyi/react_hannuota)

#### Tower类

- 一个柱子对应一个这个类的实例，该类的主要功能：
	- 通过数组`this.state.disks`来存储该柱子拥有的盘子
	- 渲染数组中的盘子到浏览器DOM中
	- 赋予柱子顶部盘子可拖动的能力、柱子接受盘子可放的能力

- 主要生命周期函数：

	- `render`：通过遍历该盘子数组，将每个盘子渲染成大小不一的盒子放在柱子上。
	- `componentDidMount/componentDidUpdate`：当盘子对应的DOM插入到浏览器后，我们在这里赋予柱子顶部盘子可拖动的能力`$(disk).draggable()`，赋予柱子接受其他盘子盘子的能力`$(tower).droppable()`

#### TowerBox

- 该类的功能是：

	- 提供存放柱子的容器
	- 统计游戏的进行时间，实现游戏计分
	- 判定盘子的移动是否可行，控制游戏规则的有效执行
	- 判断是否达成游戏目标，达成则给出相应的计分和提示

- 主要函数：

	- `checkIfDone`： 判定游戏是否达标，即第三个柱子上的盘子数是否等于所有的盘子数，若达标，则根据游戏的难度和玩家耗费的时间进行计分
	- `handleDrop` ： 当用户拖动事件结束后，会触发放事件，继而会调用该函数，在这里我们可以判定这次拖动是否有效，即大盘子不能放到小盘子上，若有效我们则进行盘子的出栈、压栈操作，接着再调用`checkIfDone`来判定游戏是否完成

## 最后

当理解了React的生命周期式设计之后，我们可以很快很容易的搭建出这么一个还算复杂的游戏，真正耗费精力的不是在游戏逻辑的实现上，而是在处理游戏界面上，我们需要构建一个在移动端桌面端都兼容的游戏，必须根据设备的类型精确的控制每一个像素点，尤其是每个盘子的宽度、高度、位置更需要仔细把控，太小了用户点不到，太大了会难看，盘子数量改变了我们也需要做相应的调整。不过只要胆大心细，通过React这些设计优良的库来构建这么一个游戏还是很简单的。